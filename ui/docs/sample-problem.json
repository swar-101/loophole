{
  "id" : 1,
  "title" : "Delete Columns to Make Sorted III",
  "source" : "leetcode",
  "sourceId" : "960",
  "description" : "You are given an array of `n` strings `strs`, all of the same length.\n\nWe may choose any deletion indices, and we delete all the characters in those indices for each string.\n\nFor example, if we have `strs = [\"abcdef\", \"uvwxyz\"]` and deletion indices `{0, 2, 3}`, then the final array after deletions is `[\"bef\", \"vyz\"]` \n\nSuppose we choose a set of deletion indices `answer` such that after deletions, the final array has **every string (row) in lexicographic** order. (i.e., `(strs[0][0]) <= strs[0][1] <= ... <= strs[0][strs[0].length - 1]` and `(strs[1][0] <= strs[1][1] <= ... <= strs[1][strs[1].length - 1])`, and so on). Return *the minimum possible value of* `answer.length`.",
  "examples" : [
    {
      "id" : 1,
      "input": "strs = [\"babca\", \"bbazb\"]",
      "output": "3",
      "explanation" : "After deleting columns 0, 1, and 4, the final array is strs = [\"bc\", \"az\"].  \nBoth these rows are individually in lexicographic order (ie. strs[0][0] <= strs[0][1] and strs[1][0] <= strs[1][1]).  \nNote that strs[0] > strs[1] - the array strs is not necessarily in lexicographic order."
    },
    {
      "id" : 2,
      "input": "strs = [\"edcba\"]",
      "output": "4",
      "explanation" : "If we delete less than 4 columns, the only row will not be lexicographically sorted."
    },
    {
      "id" : 3,
      "input": "strs = [\"ghi\",\"def\",\"abc\"]",
      "output": "0",
      "explanation" : "All rows are already lexicographically sorted."
    }
  ],

  "constraints" : [
    "n == strs.length",
    "1 <= n <= 100",
    "1 <= strs[i].length <= 100",
    "`strs[i]` consist of lowercase English letters."
  ],

  "solutions" : [],

  "learningMetadata" : {
    "scl" : 0,
    "mistakes" : [],
    "algorithms" : [],
    "revisitCount" : 0,
    "lastRevisitedAt" : -1
  }
}